// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// Diagonal Traverse
// https://leetcode.com/problems/diagonal-traverse/
// 

class Solution {
  /* Break the traverse into two category: going up or going down.
Going up: keep going. for a certain point (i,j), if (i, j) is on the top/right broad, going down.
Going down: keep going until it reaches the left/bottom broad. Then going up.
And whenever we switch direction, we need to check if it is on the right bottom point, where is the end case.
Here is the code.*/


    public int[] findDiagonalOrder(int[][] matrix) {
        if (matrix.length < 1 || matrix[0].length < 1) return new int[0];
        int[] res = new int[(matrix.length*matrix[0].length)];
        int a = 0, b = 0, index = 0;
        goUp(matrix, res, a, b, index);
        return res;
    }
    
    public static void goUp(int[][] matrix, int[] res, int a, int b, int index) {
        res[index] = matrix[a][b]; 
        while ((a != 0)&&(b != matrix[0].length-1)) {
            a--; b++; index++;
            res[index] = matrix[a][b];
        }
        if (b == matrix[0].length-1) a++; else b++;
        if (index < matrix.length*matrix[0].length-1) goDown(matrix, res, a, b, index+1);
    }
    
    public static void goDown(int[][] matrix, int[] res, int a, int b, int index) {
        res[index] = matrix[a][b];
        while ((b != 0)&&(a != matrix.length-1)) {
            b--; a++; index++;
            res[index] = matrix[a][b];
        }
        if (a == matrix.length-1) b++; else a++;
        if (index < matrix.length*matrix[0].length-1) goUp(matrix, res, a, b, index+1);
    }
    
}

