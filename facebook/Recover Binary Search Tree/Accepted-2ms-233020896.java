// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// Recover Binary Search Tree
// https://leetcode.com/problems/recover-binary-search-tree/
// 

/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
   /*首先看二叉搜索树的规律，如果将这个二叉树按照中序遍历，那么遍历完了之后得到的序列，是一个递增序列，如果将其中两个结点交换位置，那么此时的中序遍历必然不是一个递增序列，而是其中一个结点大于两边的数，其中一个结点小于两边的数，这两个结点就是被交换的两个结点。如将[1,...,i,...,j,...,n]换成[1,...,j,...,i,...,n]，其中 j 大于两边的数，i 小于两边的数。

所以要找到这两个结点也是比较容易的，中序遍历交换过的二叉树，根据上面的描述，找到两个被交换的结点，然后将结点的值相互交换，便可以得到原来的二叉搜索树。
*/
private static TreeNode first, second, pre;
public static void recoverTree(TreeNode root) {
    first = second = pre = null;
    traversal(root);
    int val = first.val;
    first.val = second.val;
    second.val = val;
}
private static void traversal(TreeNode node) {
    if (node == null) return;
    traversal(node.left);
    if (pre != null && pre.val > node.val) {
        if (first == null) first = pre;
        second = node;
    } else if (first != null && first.val < node.val) {
        return;
    }
    pre = node;
    traversal(node.right);
}
}

