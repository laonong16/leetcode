// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// Sliding Window Median
// https://leetcode.com/problems/sliding-window-median/
// 

/*The basic idea is using 2 heaps to store the larger half of window and smaller half of window.
And every time we move the window, we changed the heaps according to the removed number.

*/

class Solution {
    public double[] medianSlidingWindow(int[] nums, int k) {
        PriorityQueue<Integer> small = new PriorityQueue<>(Collections.reverseOrder());
        PriorityQueue<Integer> large = new PriorityQueue<>();
        int n = nums.length;
        double[] ans = new double[n-k+1];
        //initialize
        for (int i = 0; i < k; i++){
            if(i % 2 == 0){
                large.offer(nums[i]);
                small.offer(large.poll());
            }
            else{
                small.offer(nums[i]);
                large.offer(small.poll());
            }
        }
        boolean even = (k % 2 == 0);
        if (even) ans[0] = (small.peek()*1.0+large.peek()*1.0)/2.0;
        else ans[0] = small.peek();
        int ia = 0;
        for (int i = k; i < n; i++){
            if (nums[ia] <= ans[ia]){
                // remove the left one out of window from small heap
                small.remove(nums[ia]);
                //
                large.offer(nums[i]);
                small.offer(large.poll());
            }
            else{
                // remove the left one out of window from large heap
                 large.remove(nums[ia]);
                //
                small.offer(nums[i]);
                large.offer(small.poll());
            }
            ans[++ia] = even ? (small.peek()*1.0+large.peek()*1.0)/2.0 : small.peek();
        }
        return ans;
    }
}

