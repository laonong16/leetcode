// 
// Generated by fetch-leetcode-submission project on GitHub.
// https://github.com/gitzhou/fetch-leetcode-submission
// Contact Me: aaron67[AT]aaron67.cc
// 
// Max Consecutive Ones III
// https://leetcode.com/problems/max-consecutive-ones-iii/
// 

class Solution {
    /*
    使用双指针解题：

zeros用来记录我们考察的子序列中将0变为1的次数。
用right指针从左向右遍历数组A，right指针表示当前我们考察的子序列的最右位置，如果遇到0，则zeros++，表示增加一次翻转。
left指针用来记录当前子序列最左的位置，如果发现zeros > K, 则将left向右推进，直到zeros <= K。
推进过程中，如果遇到0，则zeros--，表示当前的0不在考察子序列当中。
left指针实际上一直在追赶right。
    */
    public int longestOnes(int[] A, int K) {
        int left =0;
        int zeros = 0;
        int result = 0;
        for (int right = 0; right < A.length; right++){
            if (A[right] == 0) {
                zeros++;
            }
            while(zeros > K) {
                if(A[left] == 0) {
                    zeros--;
                }
                left++;
            }
            result = Math.max(result, (right - left) + 1);
        }
        return result;
    }
}

